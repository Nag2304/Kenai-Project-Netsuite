/**
 * This scheduled script will generate work orders for sales order lines which have unfulfilled
 * assembly items.  Parameters on the script allow the user to specify a fulfillment date.
 *
 * @appliedtorecord salesorder
 * @appliedtorecord workorder
 *
 * @requires 360.js
 * @requires 360.log.js
 * @requires 360.search.js
 *
 * @copyright 360 Cloud Solutions, 2016
 * @author Matt Dahse mdahse@360cloudsolutions.com
 */

/* NAMESPACE DECLARATIONS */

var _CCC = _CCC || {};
var RESET_FOLDER = '-15'; // Suite Scripts folder is default

_CCC.generateWorkOrders = _CCC.generateWorkOrders || {};

_CCC.generateWorkOrders.assemblyTree = {};

$360.log.show();

_CCC.generateWorkOrders.startScheduled = function startScheduled(type) {
  try {
    /* {String} The title of log messages generated by this function */
    var where = arguments.callee.name;

    /* {Object} Namespace alias */
    var self = _CCC.generateWorkOrders;

    /* {Object} Object which maps all assembly items with their subassemblies and sub-subassemblies */
    self.assemblyTree = self.buildAssemblyTree();

    /* {Object} Script parameters */
    var params = self.getScriptParameters();

    /* {Object[]} Transaction lines requiring work orders */
    var results = params.custscript_360_workorder_dataobj
      ? []
      : self.getSearchResults(params);

    /* {Object} Above results sorted into an object with locations, each with a list of items and sales orders */
    var data = params.custscript_360_workorder_dataobj
      ? getObjectFromData(params.custscript_360_workorder_dataobj)
      : self.sortResultsByItem(results);

    /*{Object} - Array stores what work order link  sales order lines need to be updated with. Allows SO to be submitted once*/
    var salesOrderUpdatesObj = params.custscript_360_workorder_salesorderobj
      ? getObjectFromData(params.custscript_360_workorder_salesorderobj)
      : {};

    /* Governance needed - if not available, break out and reschedule */

    var usage = 500;

    /* {Object} represents data to create one work order */
    var order = {};

    /* {String} id of the work order being created */
    var workOrderId = '';

    /* Top level assemblies needed at a location */
    var itemListAtLocation = [];

    /* {Object} contains the 'internalid', 'location', and 'item' belonging to the last work order created */
    var lastWorkOrder = params.custscript_lastworkorder
      ? nlapiLookupField('workorder', params.custscript_lastworkorder, [
          'internalid',
          'location',
          'item',
        ])
      : null;

    // Set Reset Folder
    RESET_FOLDER = params.custscript_360_wo_resetfolder;

    /* CREATE WORK ORDERS */
    for (var location in data) {
      itemListAtLocation = self.getItemsAtLocation(data[location]);

      /* If this location has already been processed, do not re-create Subassembly Work Orders */
      if (!lastWorkOrder || lastWorkOrder.location != location) {
        /* Create all of the subassemblies needed to create the top level assemblies */
        self.createSubassemblyWorkOrders(itemListAtLocation, data[location]);
      }

      for (var item in data[location]) {
        order = data[location][item];

        /* Check Usage */
        $360.log.debug(
          'USAGE: ' + nlapiGetContext().getRemainingUsage(),
          where
        );
        if (nlapiGetContext().getRemainingUsage() < usage) {
          /* Set object storage params */
          var dataObjFile = makeDataFile(
            'dataObj',
            JSON.stringify(data),
            params
          );
          params.custscript_360_workorder_dataobj = dataObjFile;
          params.custscript_360_workorder_salesorderobj = makeDataFile(
            'salesOrderObj',
            JSON.stringify(salesOrderUpdatesObj),
            params
          );
        }

        /* Discontinue script logic if reschedule occurs */
        if ($360.rescheduled(usage, params)) {
          $360.log.debug('Script Restart via 360', where);
          return;
        }

        /* If a Work Order has already been created for this item at this location, do not re-create Work Order */
        if (
          lastWorkOrder &&
          lastWorkOrder.location == location &&
          lastWorkOrder.item == item
        ) {
          workOrderId = lastWorkOrder.internalid;
        } else {
          /* Create new Work Order */
          workOrderId = self.createWorkOrder(order);

          /* Update 'last work order' parameter (for rescheduling purposes) */
          params.custscript_lastworkorder = workOrderId;
        }

        /* Update Sales Order Object*/
        salesOrderUpdatesObj = self.updateSalesOrdersObj(
          order,
          workOrderId,
          salesOrderUpdatesObj
        );

        // Delete Item out of object after work order is created
        delete data[location][item];
      }
      // Delete Location out of object after all items gone through
      delete data[location];
    }

    /* UPDATE SALES ORDER LINES WITH WORK ORDER LINKS */

    try {
      /* Once the work orders are done creating, update what is stored in file cabinet in case
       * there is an error - this way can always restart script and have it just start updating Sales Orders */
      params.custscript_360_workorder_dataobj = makeDataFile(
        'dataObj',
        JSON.stringify({}),
        params
      );
      params.custscript_360_workorder_salesorderobj = makeDataFile(
        'salesOrderObj',
        JSON.stringify(salesOrderUpdatesObj),
        params
      );

      $360.log.debug('Updating Sales Orders: ', where);
      /* If not all sales orders updated a restart likely occurred, exit script */
      if (!self.updateSalesOrders(salesOrderUpdatesObj, params)) {
        return;
      }
    } catch (e) {
      $360.log.error('Error updating sales order: ' + e.details, where);
      return;
    }
  } catch (e) {
    $360.log.error('Error creating workorders: ' + JSON.stringify(e), where);

    /* Create Recovery Files*/
    params.custscript_360_workorder_dataobj = makeDataFile(
      'dataObj',
      JSON.stringify({}),
      params
    );
    params.custscript_360_workorder_salesorderobj = makeDataFile(
      'salesOrderObj',
      JSON.stringify(salesOrderUpdatesObj),
      params
    );
    return;
  }
  // Delete Recovery files if any
  if (params.custscript_360_workorder_dataobj) {
    nlapiDeleteFile(params.custscript_360_workorder_dataobj);
  }

  if (params.custscript_360_workorder_salesorderobj) {
    nlapiDeleteFile(params.custscript_360_workorder_salesorderobj);
  }

  $360.log.audit('Finished creating work orders.', where);
};

/* SUPPORT FUNCTIONS */

/**
 * Function to get the items that are needed at a specific location
 *
 * @param locationObject {Object} A single location member of an item object describing items needed at a location
 * @return {Object[]} Array of items with quantities needed at that location
 * @memberOf _CCC.generateWorkOrders
 */
_CCC.generateWorkOrders.getItemsAtLocation = function getItemsAtLocation(
  locationObject
) {
  /* {Object[]} Data to be returned */
  var items = [];

  for (var item in locationObject) {
    items.push({
      item: locationObject[item].item,
      quantity: locationObject[item].quantity,
    });
  }

  return items;
};

/**
 * Function to get the script parameters and package them up as an object.
 *
 * @return {Object} Script parameters as key/value pairs
 * @memberOf _CCC.generateWorkOrders
 */
_CCC.generateWorkOrders.getScriptParameters = function getScriptParameters() {
  /* {nlobjContext} */
  var context = nlapiGetContext();

  /* {Object} Data to be returned */
  var params = {};

  params.custscript_auto_wo_location = context.getSetting(
    'SCRIPT',
    'custscript_auto_wo_location'
  );
  params.custscript_auto_wo_salesdate = context.getSetting(
    'SCRIPT',
    'custscript_auto_wo_salesdate'
  );
  params.custscript_lastworkorder = context.getSetting(
    'SCRIPT',
    'custscript_lastworkorder'
  );
  params.custscript_360_workorder_dataobj = context.getSetting(
    'SCRIPT',
    'custscript_360_workorder_dataobj'
  );
  params.custscript_360_workorder_salesorderobj = context.getSetting(
    'SCRIPT',
    'custscript_360_workorder_salesorderobj'
  );
  params.custscript_360_wo_resetfolder =
    context.getSetting('SCRIPT', 'custscript_360_wo_resetfolder') || '-15';

  return params;
};

/**
 * Find the sales order lines which will need to have work orders created.
 *
 * <h5>API Governance:</h5>
 * <p>
 * This function uses <code>10</code> units each time it is invoked.
 * </p>
 *
 * @param params {Object} Object containing the script parameter values set on the deployment
 * @return {Object[]} results of the search in a plain object array
 * @memberOf _CCC.generateWorkOrders
 */
_CCC.generateWorkOrders.getSearchResults = function getSearchResults(params) {
  /* {String} */
  var where = arguments.callee.name;

  /* {Object} Namepsace object */
  var self = _CCC.generateWorkOrders;

  /* {nlobjSearchFilter[]} */
  var filters = [];

  /* {nlobjSearchColumn[]} */
  var columns = [];

  filters.push(new nlobjSearchFilter('mainline', null, 'is', 'F'));
  filters.push(new nlobjSearchFilter('shiprecvstatusline', null, 'is', 'F'));
  filters.push(new nlobjSearchFilter('type', 'item', 'anyof', 'Assembly'));
  filters.push(
    new nlobjSearchFilter('custcol_360_generated_wo', null, 'anyof', '@NONE@')
  );

  /* Add a filter to eliminate closed lines: */
  filters.push(new nlobjSearchFilter('closed', null, 'is', 'F'));

  if (params.custscript_auto_wo_location) {
    filters.push(
      new nlobjSearchFilter(
        'location',
        null,
        'anyof',
        params.custscript_auto_wo_location
      )
    );
  }

  if (params.custscript_auto_wo_salesdate) {
    filters.push(
      new nlobjSearchFilter(
        'custbody_fulfillment_date',
        null,
        'on',
        params.custscript_auto_wo_salesdate
      )
    );
  } else {
    filters.push(
      new nlobjSearchFilter(
        'custbody_fulfillment_date',
        null,
        'onorbefore',
        'today'
      )
    );
  }

  columns.push(new nlobjSearchColumn('item'));
  columns.push(new nlobjSearchColumn('linesequencenumber'));
  columns.push(new nlobjSearchColumn('location'));
  columns.push(new nlobjSearchColumn('quantity'));
  columns.push(new nlobjSearchColumn('department'));
  columns.push(new nlobjSearchColumn('internalid'));

  var results = $360.search.searchRecordPaged({
    type: 'salesorder',
    filters: filters,
    columns: columns,
    returnAsGenericObjectArray: true,
  });

  $360.log.audit(
    'Found ' + results.length + ' sales order lines to update.',
    where
  );

  return results;
};

/**
 * This function consolidates the results of the sales order line search, combining like objects to
 * reduce the number of work orders which need to be created.
 *
 * @param results {Object[]} plain object search results representing item lines on sales orders
 * @return {Object} a consolidated object in which transaction line information is combined for each distinct item
 * @memberOf _CCC.generateWorkOrders
 */
_CCC.generateWorkOrders.sortResultsByItem = function sortResultsByItem(
  results
) {
  /* {Object} data to be returned */
  var data = {};

  /* {String} Placeholder for a location element */
  var loc = '';

  /* {String} placeholder for an item id element */
  var item = '';

  results.forEach(function (result) {
    /* Loc will be the top tier of the object */
    loc = result.location;

    /* Under each location will be the items needed for that location */
    item = result.item;

    if (!data[loc]) {
      data[loc] = {};
    }

    if (!data[loc][item]) {
      data[loc][item] = { salesOrders: [], quantity: 0 };
    }

    data[loc][item].location = loc;
    data[loc][item].region = result.department;
    data[loc][item].item = item;

    /* Keep track of which sales orders required this item so they can be updated when the work order is created */
    data[loc][item].salesOrders.push({
      id: result.internalid,
      line: result.linesequencenumber,
    });

    /* Add to the quantity of this item if it already exists */
    data[loc][item].quantity += parseFloat(result.quantity) || 0;
  });

  return data;
};

/**
 * Creates a work order for a top level assembly item which appears on one or more sales order lines.
 *
 * <h5>API Governance:</h5>
 * <p>
 * This function uses <code>30</code> units each time it is invoked.
 * </p>
 *
 * @param itemObj {Object} Object describing the location, region, itemid, and quantity required for the work order
 * @return {String} internal id of the work order
 * @memberOf _CCC.generateWorkOrders
 */
_CCC.generateWorkOrders.createWorkOrder = function createWorkOrder(itemObj) {
  /* {nlobjRecord} */
  var workOrderRec = nlapiCreateRecord('workorder');

  /* {String} */
  var workOrderId = '';

  workOrderRec.setFieldValue('location', itemObj.location);
  workOrderRec.setFieldValue('department', itemObj.region);
  workOrderRec.setFieldValue('assemblyitem', itemObj.item);
  workOrderRec.setFieldValue('quantity', itemObj.quantity);

  try {
    workOrderId = nlapiSubmitRecord(workOrderRec);
    $360.log.audit(
      'Created workorder ' + workOrderId + ' for item ' + itemObj.item,
      arguments.callee.name
    );
  } catch (e) {
    $360.log.audit(
      'Failed to create work order for item ' +
        itemObj.item +
        ' at location ' +
        itemObj.location +
        ': ' +
        e,
      arguments.callee.name
    );
  }

  return workOrderId;
};

/**
 * This function updates the sales order lines with the work orders that were generated.  Sales order lines
 * which are updated here will no longer be valid results for the search for transactions.
 *
 * <h5>API Governance:</h5>
 * <p>
 * This function uses <code>30</code> units each Sales Order that needs to be updated.
 * </p>
 *
 * @param updatesObj {Object}
 * @param params {Object} script parameter object, for rescheduling purposes
 * @return {Boolean} true if all sales orders updated without rescheduling, else false
 * @memberOf _CCC.generateWorkOrders
 */
_CCC.generateWorkOrders.updateSalesOrders = function updateSalesOrders(
  updatesObj,
  params
) {
  try {
    /* {String} */
    var where = arguments.callee.name;

    /* {Object} Namespace alias */
    var self = _CCC.generateWorkOrders;

    /* {nlobjRecord} */
    var soRec = null;

    /* {Number} The index of the line that needs to be updated with the work order id  */
    var line = 0;

    /* {nlobjContext} */
    var context = nlapiGetContext();
    for (soId in updatesObj) {
      $360.log.debug('Attempting Update of SO: ' + soId, where);

      if (context.getRemainingUsage() < 500) {
        /* Set object storage params */
        params.custscript_360_workorder_dataobj = makeDataFile(
          'dataObj',
          JSON.stringify({}),
          params
        );
        params.custscript_360_workorder_salesorderobj = makeDataFile(
          'salesOrderObj',
          JSON.stringify(updatesObj),
          params
        );
        $360.log.debug(
          'USAGE: ' + nlapiGetContext().getRemainingUsage(),
          where
        );

        if ($360.rescheduled(500, params)) {
          return false;
        }
      }
      soRec = nlapiLoadRecord('salesorder', soId);

      for (line in updatesObj[soId]) {
        /* Find the line that has the item and has not yet been marked with a work order */
        soLine = self.findNextLineIndexForItem(
          soRec,
          updatesObj[soId][line].itemId
        );

        if (soLine == null) {
          $360.log.error(
            'Cannot update sales order ' +
              soId +
              ' - item ' +
              updatesObj[soId][line].itemId +
              ' not found unfulfilled on any line.',
            where
          );
        } else {
          /* Update the line */
          soRec.setLineItemValue(
            'item',
            'custcol_360_generated_wo',
            soLine,
            updatesObj[soId][line].workOrderId
          );
        }
      }
      try {
        nlapiSubmitRecord(soRec);
        $360.log.audit('Updated sales order ' + soId, where);
      } catch (e) {
        $360.log.error(
          'Failed to update sales order ' + soId + ': ' + e,
          where
        );
      }

      delete updatesObj[soId];
    }
  } catch (e) {
    makeDataFile('salesOrderObj', JSON.stringify(updatesObj), params);
    $360.log.error('Failed to update sales orders : ' + e, where);
  }
  return true;
};

/**
 * This function updates the sales order Array with what sales order lines need a link to the new work order
 *
 * <h5>API Governance:</h5>
 * <p>
 * This function uses <code>0</code> units each Sales Order that needs to be updated.
 * </p>
 *
 * @param itemObj {Object} Object describing the transaction lines being updated
 * @param workOrderId {String} Internal id of the work order created
 * @param salesOrderUpdatesObj {Object}
 * @return {Object}
 * @memberOf _CCC.generateWorkOrders
 */
_CCC.generateWorkOrders.updateSalesOrdersObj = function updateSaleOrdersArray(
  itemObj,
  workOrderId,
  salesOrderUpdatesObj
) {
  /* {String} */
  var where = arguments.callee.name;

  /* {Object} Namespace alias */
  var self = _CCC.generateWorkOrders;

  /* {String[]} List of sales order ids that contain the item being built on one or more lines */
  var salesOrders = itemObj.salesOrders;

  for (var i = 0; i < salesOrders.length; i++) {
    so = salesOrders[i];

    /* Check to see if sales order is in object yet */
    if (!salesOrderUpdatesObj[so.id]) {
      salesOrderUpdatesObj[so.id] = {};
    }
    /* Add what line in the SO needs a link to the new work order */
    salesOrderUpdatesObj[so.id][so.line] = {
      workOrderId: workOrderId,
      itemId: itemObj.item,
    };
  }

  return salesOrderUpdatesObj;
};

/**
 * This helper function finds an item on a sales order record's item list which matches a given item id, and
 * which has not yet been marked with a generated work order.
 *
 * @param soRec {nlobjRecord}
 * @param itemId {String} internal id of an item
 * @return {Number} Index of the line to be updated
 * @memberOf _CCC.generateWorkOrders
 */
_CCC.generateWorkOrders.findNextLineIndexForItem =
  function findNextLineIndexForItem(soRec, itemId) {
    /* {Number}  */
    var itemCount = soRec.getLineItemCount('item');

    for (var i = 1; i <= itemCount; i++) {
      /* Item matches the one we are looking for and the line is not yet updated */
      if (
        soRec.getLineItemValue('item', 'item', i) == itemId &&
        !soRec.getLineItemValue('item', 'custcol_360_generated_wo', i)
      ) {
        return i;
      }
    }

    return null;
  };

/**
 * This function consults the assembly tree to determine what quantity of each subassembly will be needed
 * and what quantity of each subassembly of that subassembly will be needed to create the given quantity
 * of the given item.
 *
 * It returns an array of objects (one per component) which each describe an assembly and a quantity needed.
 *
 * @param item {String} internalid of an assembly item (top level assembly)
 * @param quantity {Number} The quantity of that item which need to be built
 * @param numSales {Number} The number of sales order lines on which this item appears
 * @return {Object[]} Array of objects describing the components that need to be built for the top level (parent) BOM
 *  <pre>
 *  [
 *  	{"item":"7348","parent":"7349","quantity":9},
 *  	{"item":"7347","parent":"7349","quantity":18}
 *  ]
 *  </pre>
 *  @memberOf _CCC.generateWorkOrders
 */
_CCC.generateWorkOrders.getSubassembliesForItem =
  function getSubassembliesForItem(item, quantity, numSales) {
    /* {Object[]} Array of objects to be returned */
    var subassemblies = [];

    /* {Object} Placeholder object to be used during the loop */
    var subassembly = {};

    /* {Object} Hierarchy of the current item's assemblies, subassemblies, and sub-subassemblies */
    var tree = _CCC.generateWorkOrders.assemblyTree[item];

    /* If the current item has no subassemblies, return an empty array.  We're done. */
    if (!tree.components) {
      return subassemblies;
    }

    /* For each subassembly in this assembly */
    tree.components.forEach(function (component) {
      /* Add the component to the list.  Multiply quantity needed for the build by quantity of builds sold */
      subassembly = {
        item: component.item,
        parent: item,
        quantity: quantity * component.quantity,
        salesAffected: numSales,
      };

      subassemblies.push(subassembly);

      /* If that subassembly has subassemblies of its own that need to be built */
      if (component.components) {
        /* For each sub-subassembly, quantity is total sold, times quantity of parent, times its own quantity in the build */
        component.components.forEach(function (subitem) {
          subassembly = {
            item: subitem.item,
            parent: item,
            quantity: quantity * component.quantity * subitem.quantity,
            salesAffected: numSales,
          };
          subassemblies.push(subassembly);

          /* If this subassembly has yet another layer inside it */
          if (subitem.components) {
            /* For each sub-subassembly, quantity is total sold, times quantity of parent, times its own quantity in the build */
            subitem.components.forEach(function (subSubitem) {
              subassembly = {
                item: subSubitem.item,
                parent: item,
                quantity:
                  quantity *
                  component.quantity *
                  subitem.quantity *
                  subSubitem.quantity,
                salesAffected: numSales,
              };
              subassemblies.push(subassembly);
            });
          }
        });
      }
    });

    return subassemblies;
  };

/**
 * This function creates the work orders necessary to build the subassemblies which are
 * required for the top-level assemblies on the sales order lines.
 *
 * <h5>API Governance:</h5>
 * <p>
 * This function uses <code>30n</code> units each time it is invoked, where n is the number of
 * unique subassemblies needed for top level assemblies at that location.
 * </p>
 *
 * @param itemList {Object[]} Array of objects which describe the top-level assemblies being created
 * @param itemObj {Object} Information about the transaction lines which will need to be built at a location
 * @return {void}
 * @memberOf _CCC.generateWorkOrders;
 */
_CCC.generateWorkOrders.createSubassemblyWorkOrders =
  function createSubAssemblyWorkOrders(itemList, itemObj) {
    /* {Object} Namespace alias */
    var self = _CCC.generateWorkOrders;

    /* {Object[]} List of objects describing the subassemblies needed and their required quantities */
    var subassemblies = [];

    itemList.forEach(function (item) {
      subassemblies = subassemblies.concat(
        self.getSubassembliesForItem(
          item.item,
          item.quantity,
          itemObj[item.item].salesOrders.length
        )
      );
    });

    subassemblies = self.aggregateSubassemblies(subassemblies);

    /* If they have set the "Use Available Inventory First" parameter on the script */

    if (
      nlapiGetContext().getSetting(
        'SCRIPT',
        'custscript_360_use_avail_first'
      ) == 'T' &&
      subassemblies.length
    ) {
      /* {Object} Map of items to quantity available at the current location such as {'1234': 2, '4567': 0} */
      var onHand = self.getOnHandInventory(
        subassemblies,
        itemObj[subassemblies[0].parent].location
      );

      /* Adjust the subassemblies array to eliminate or reduce required quantities where inventory already exists */
      subassemblies = self.reduceRequiredQuantities(subassemblies, onHand);
    }

    /* {nlobjRecord} */
    var workOrderRec = null;

    /* {String} Id of the created work order, used for logging purposes only */
    var workOrderId = '';

    /* {string} A location-item combination string that will be used to determine if the work order for this already exists */
    var key = '';

    /* {string[]} An array of keys representing subassembly work orders that were already created today */
    var existingWorkOrderKeys = [];

    if (
      nlapiGetContext().getSetting(
        'SCRIPT',
        'custscript_process_late_orders'
      ) != 'T'
    ) {
      existingWorkOrderKeys = self.getExistingSubassemblyWorkOrders();
    }

    /* Create a work order for each unique subassembly item for this location */
    subassemblies.forEach(function (result) {
      key = itemObj[result.parent].location + '-' + result.item;

      if (existingWorkOrderKeys.indexOf(key) > -1) {
        $360.log.error(
          'Detected duplicate subassembly work order: ' +
            key +
            '.  Skipping creation.',
          arguments.callee.name
        );
        return;
      }

      workOrderRec = nlapiCreateRecord('workorder');

      workOrderRec.setFieldValue('location', itemObj[result.parent].location);
      workOrderRec.setFieldValue('department', itemObj[result.parent].region);
      workOrderRec.setFieldValue('assemblyitem', result.item);
      workOrderRec.setFieldValue('quantity', result.quantity);
      workOrderRec.setFieldValue(
        'custbody_360_num_sales_affected',
        result.salesAffected
      );

      try {
        workOrderId = nlapiSubmitRecord(workOrderRec);
      } catch (e) {
        $360.log.error(
          'Unable to create subassembly workorder! item: ' +
            result.item +
            ' quantity: ' +
            result.quantity,
          arguments.callee.name
        );
        throw e;
      }

      $360.log.audit(
        'Created subassembly work order ' +
          workOrderId +
          ' for member item ' +
          result.item,
        arguments.callee.name
      );
    });
  };

/**
 * This function builds an array of strings that identify the subassembly work orders that have already been created today
 * before the current process begins.
 *
 * @return {string[]}
 * @memberOf _CCC.generateWorkOrders
 */
_CCC.generateWorkOrders.getExistingSubassemblyWorkOrders =
  function getExistingSubassemblyWorkOrders() {
    /* {nlobjSearchFilter[]} */
    var filters = [];

    /*{nlobjSearchColumn[]} */
    var columns = [];

    filters.push(new nlobjSearchFilter('trandate', null, 'on', 'today'));
    filters.push(new nlobjSearchFilter('mainline', null, 'is', 'T'));
    filters.push(
      new nlobjSearchFilter(
        'custbody_360_num_sales_affected',
        null,
        'greaterthan',
        '0'
      )
    );

    columns.push(new nlobjSearchColumn('location'));
    columns.push(new nlobjSearchColumn('item'));

    /* {nlobjSearchResult[]} */
    var results = nlapiSearchRecord('workorder', null, filters, columns) || [];

    /* {string[]} The data to be returned */
    var subassemblyWorkOrders = [];

    /* {string} Each key (location + "-" + item) within the loop */
    var key = '';

    results.forEach(function (result) {
      key = result.getValue('location') + '-' + result.getValue('item');
      subassemblyWorkOrders.push(key);
    });

    return subassemblyWorkOrders;
  };

/**
 * This function performs a search of available inventory levels at the target location for each of the items in the
 * subassemblies array.  It returns an object with item ids as keys and item inventory levels as values.
 *
 * <h5>API Governance:</h5>
 * <p>
 * This function uses <code>10</code> units each time it is invoked.
 * </p>
 *
 * @param subassemblies {Object[]} The subassemblies required for this run
 * @param location {String} Internalid of the current location being processed
 * @return {Object} Map of item internal ids with available quantity for each
 * @memberOf _CCC.generateWorkOrders
 */
_CCC.generateWorkOrders.getOnHandInventory = function getOnHandInventory(
  subassemblies,
  location
) {
  /* {Object} The data to be returned */
  var onHand = {};

  /* {String[]} A list of internal ids of subassembly items */
  var items = [];

  subassemblies.forEach(function (item) {
    items.push(item.item);
  });

  /* {nlobjSearchFilter[]} */
  var filters = [];

  /* {nlobjSearchColumn[]} */
  var columns = [];

  filters.push(new nlobjSearchFilter('internalid', null, 'anyof', items));
  filters.push(
    new nlobjSearchFilter('inventorylocation', null, 'anyof', location)
  );

  columns.push(new nlobjSearchColumn('locationquantityavailable'));

  /* {nlobjSearchResult[]} */
  var results = nlapiSearchRecord('assemblyitem', null, filters, columns) || [];

  results.forEach(function (result) {
    onHand[result.getId()] =
      parseFloat(result.getValue('locationquantityavailable')) || 0;
  });

  return onHand;
};

/**
 * This function translates the subassemblies object, reducing the quantities to be built by the inventory
 * already available in the current location, so that if we need 10lbs of coffee and already have 2, we build only
 * 8 lbs.  Subassemblies that are hereby reduced to 0 or below (we have all we need already) will be eliminated
 * so that no work order is generated for them.
 *
 * @param subassemblies {Object[]} The subassemblies that need to be built for the location
 * @param onHand {Object} Available inventory levels at the current location for the items in subassemblies
 * @memberOf _CCC.generateWorkOrders
 */
_CCC.generateWorkOrders.reduceRequiredQuantities =
  function reduceRequiredQuantities(subassemblies, onHand) {
    /* {Object[]} The data to be returned. */
    var delta = [];

    /* {Number} Placeholder value for the original quantity for a subassembly (based on its parent quantity */
    var originalQty = 0;

    /* {Number} Placeholder value for the on hand quantity of this item at the current location */
    var onHandQty = 0;

    /* {Number} Placeholder value for the difference between what is needed and what is available */
    var newQty = 0;

    subassemblies.forEach(function (item) {
      originalQty = item.quantity;
      onHandQty = onHand[item.item];

      newQty = originalQty - onHandQty;

      /* If the new quantity is 0 or less, remove the item from the list - we have enough and don't need to build anything */
      if (newQty > 0) {
        delta.push({
          item: item.item,
          quantity: newQty,
          parent: item.parent,
          salesAffected: item.salesAffected,
        });
      }
    });

    return delta;
  };

/**
 * Simple function to combine the identical subassemblies in the list so that a single large workorder
 * can be generated instead of a half-dozen smaller ones for the same item.
 *
 * @param subassemblies {Object[]} array of {item: '123', quantity: 2} objects representing subassemblies needed.
 * @returns {Object[]} Consolidated array, with duplicates removed and quantities adjusted.
 * @memberOf _CCC.generateWorkOrders
 */
_CCC.generateWorkOrders.aggregateSubassemblies =
  function aggregateSubassemblies(subassemblies) {
    /* {Object[]} The consolidated array we will return */
    var stackedList = [];

    /* {String} An array to bookmark the unique subassemblies */
    var uniqueItems = [];

    /* {Number} index bookmark to find items that already exist */
    var index;

    /* Loop through each subassembly in the list*/
    subassemblies.forEach(function (subassembly) {
      /* Try and find it in the uniqueItems array */
      index = uniqueItems.indexOf(subassembly.item);

      /* If not found, add it to the array and to the return array */
      if (index == -1) {
        uniqueItems.push(subassembly.item);
        stackedList.push(subassembly);

        /* Otherwise just add its quantity to the one that is already there. */
      } else {
        stackedList[index].quantity += subassembly.quantity;

        /* Additional occurences of this subassebly indicate multiple sales order lines that require it */
        stackedList[index].salesAffected += subassembly.salesAffected;
      }
    });

    return stackedList;
  };

/**
 * This function performs a search for all assembly items in the system, returning one
 * result for each component with the quantity needed of that component to create the assembly.
 *
 * <h5>API Governance:</h5>
 * <p>
 * This function uses <code>10</code> units each time it is invoked.
 * </p>
 *
 * @return {nlobjSearchResult[]}
 * @memberOf _CCC.generateWorkOrders
 */
_CCC.generateWorkOrders.getAllAssemblies = function getAllAssemblies() {
  /* {nlobjSearchColumn[]} */
  var columns = [];

  /* The type of the component */
  columns.push(new nlobjSearchColumn('type', 'memberitem'));

  /* The quantity of this component needed to build a unit of the parent item */
  columns.push(new nlobjSearchColumn('memberquantity'));

  /* Internal id of the component (subassembly) */
  columns.push(new nlobjSearchColumn('memberitem'));

  results = $360.search.searchRecordPaged({
    type: 'assemblyitem',
    filters: [],
    columns: columns,
  });

  return results;
};

/**
 * Creates a text file in the file cabinant holding stringified object data to use during rescheduling
 * @param title {String} - Title to use in file name
 * @param contents {String} - stringified content to place in file.
 * @params params {object} - script parameters
 * @return {String} - file id
 */
function makeDataFile(title, contents, params) {
  var where = 'makeDataFile';

  try {
    var date = params.custscript_auto_wo_salesdate
      ? params.custscript_auto_wo_salesdate
      : nlapiDateToString(new Date());
    var file = nlapiCreateFile(
      'workorderGeneration_' + title + date + '.txt',
      'PLAINTEXT',
      contents
    );
    file.setFolder(RESET_FOLDER);
    return nlapiSubmitFile(file);
  } catch (e) {
    $360.log.error('Error making file' + e.message, where);
    throw 'Recovery point failed to save';
  }
}

/**
 * Creates an object from stringified data stored in a file
 * @param fileId {String} - File id to load and retrieve content from
 * @return {Object}
 */
function getObjectFromData(fileId) {
  try {
    var fileContents = nlapiLoadFile(fileId).getValue();
    return JSON.parse(fileContents);
  } catch (e) {
    $360.log.error('Error parsing file' + e.message, where);
    throw 'Failed to register recovery point';
  }
}

/**
 * This function loops through the results of an assembly item search and
 * builds a hierarchy containing each assembly item and its subassembly components, and
 * the subassembly components of those subassembly components (3 levels deep), with the quantity
 * of each component required to build its immediate parent.
 * 
 * @returns {Object}
 * <pre>
{
 	"7313": {
		"components": [{
			"item": "5133",
			"quantity": "1"
		}]
	},
	"7314": {
		"components": [{
			"item": "5048",
			"quantity": "1",
			"components": [{
				"item": "4858",
				"quantity": "1.21212"
			}]
		}]
	}, ...
}
 * </pre>
 * @memberOf _CCC.generateWorkOrders
 */
_CCC.generateWorkOrders.buildAssemblyTree = function buildAssemblyTree() {
  /* {Object} Namespace object */
  var self = _CCC.generateWorkOrders;

  /* {Object} The object to be returned */
  var tree = {};

  /* {nlobjSearchResult[]} All the assemblies.  All of them. */
  var results = _CCC.generateWorkOrders.getAllAssemblies();

  /* First pass adds 2 levels of assemblies - the parent item and any direct assembly components
   * Supports 2-level deep assemblies which are bags(1) of roasted(2) coffee */
  results.forEach(function (result) {
    /* Add the assembly item to the root level if it does not already exist */
    tree[result.getId()] = tree[result.getId()] || {};

    /* Add the assembly's member item to the second tier if it is also an assembly */
    if (
      result.getValue('type', 'memberitem') == 'Assembly' &&
      !self.componentIsListed(tree[result.getId()].components, result)
    ) {
      tree[result.getId()].components = tree[result.getId()].components || [];
      tree[result.getId()].components.push({
        item: result.getValue('memberitem'),
        quantity: result.getValue('memberquantity'),
      });
    }
  });

  /* This pass adds a third level of assembly support
   * either bags(1) of blends(2) of roasted(3) coffee OR cases(1) of bags(2) of roasted(3) coffee */
  results.forEach(function (result) {
    /* Now loop through all existing subassembly components and see if
     * this result is an ingredient in any of them.*/
    for (var branch in tree) {
      if (!tree[branch].components) {
        continue;
      }
      tree[branch].components.forEach(function (component) {
        if (
          component.item == result.getId() &&
          result.getValue('type', 'memberitem') == 'Assembly' &&
          !self.componentIsListed(component.components, result)
        ) {
          component.components = component.components || [];
          component.components.push({
            item: result.getValue('memberitem'),
            quantity: result.getValue('memberquantity'),
          });
        }
      });
    }
  });

  /* At this point the tree is 3 assemblies deep - one more pass adds the 4th level to support
   * cases(1) of bags(2) of blends(3) of roasted(4) coffee */
  results.forEach(function (result) {
    /* Now loop through all existing sub-subassembly components and see if
     * this result is an ingredient in any of them.*/
    for (var branch in tree) {
      if (!tree[branch].components) {
        //skip non-assembly components
        continue;
      }
      tree[branch].components.forEach(function (component) {
        // for each component of the subassembly
        if (!component.components) {
          return;
        }
        component.components.forEach(function (subcomponent) {
          if (
            subcomponent.item == result.getId() &&
            result.getValue('type', 'memberitem') == 'Assembly' &&
            !self.componentIsListed(subcomponent.components, result)
          ) {
            subcomponent.components = subcomponent.components || [];
            subcomponent.components.push({
              item: result.getValue('memberitem'),
              quantity: result.getValue('memberquantity'),
            });
          }
        });
      });
    }
  });

  return tree;
};

/**
 * Checks to see if the component has already been listed in the current node of the assembly tree.
 *
 * Because multiple results are returned for each top-level assembly and subassembly with multiple
 * child components, this function prevents duplicate entries.
 *
 * @param componentList {Object[]} List of component objects
 * @param result {N/search.Result} The search result being validated
 * @returns {boolean} true if this component is listed, false if not
 * @memberOf _CCC.generateWorkOrders
 */
_CCC.generateWorkOrders.componentIsListed = function componentIsListed(
  componentList,
  result
) {
  /* If there are no subassemblies under the assembly, this will be undefined */
  if (!componentList) {
    return false;
  }

  /* {Object} Placeholder for the current component in the list */
  var component = {};

  for (var i = 0; i < componentList.length; i++) {
    component = componentList[i];

    if (component.item == result.getValue('memberitem')) {
      return true;
    }
  }

  return false;
};
